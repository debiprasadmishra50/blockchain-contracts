<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="Blockchain Notes" />
    <meta name="author" content="Debi Prasad Mishra" />
    <title>Blockchain Notes</title>
    <style>
        body {
            max-width: fit-content;
        }
        pre {
            white-space: pre-wrap;
        }
        
        #contents {
            /* text-align: center; */
            margin-left: 10%;
            margin-right: 10%;
            display: flex;
            justify-content: space-between;

        }
        #to-top {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background-color: #efefef;
            color: black;
            padding: 10px;
        }
        #to-top a {
            text-decoration: none;
            color: black;
            font-weight: bold;
        }

    </style>
</head>
<body>
    
    <div id="contents">
      <a href="#csamm">CSAMM</a>
      <a href="#cpamm">CPAMM</a>
      <a href="#vault">Vault</a>
      <a href="#syntetix">Syntetix</a>
      <a href="#compound">Compound</a>
      <a href="#uniswap">UNISWAP</a>
    </div>  

    <div id="to-top">
        <a href="#contents">Back To Top üîù</a>
    </div>

<div id="intro">
<pre>
        
Application Ecosystem
------------------------------
    - Centralized: App that run on a single server or a single computer and performs its various functions under a single authority.

    - Decentralized: also known as "dApps" or "dapps"‚Äîare digital applications that run on a blockchain network of computers instead of relying on a single computer. Because dApps are decentralized, they are free from the control and interference of a single authority.

- Dapps have their backend code (smart contracts) running on a decentralised network and not a centralized server. They use the Ethereum blockchain for data storage and smart contracts for their app logic. A smart contract is like a set of rules that live on-chain for all to see and run exactly according to those rules.

- Dapps enable peer-to-peer(P2P) communication/trading/transaction without involvement of a third-party or a middleware.

https://www.youtube.com/watch?v=HcOWNxL3Iy0

https://www.youtube.com/watch?v=3xGLc-zz9cA&list=RDLV93E_GzvpMA0&index=2

https://www.youtube.com/watch?v=93E_GzvpMA0


Blockchain and Ethereum
=======================================
- Blockchain is a shared, immutable ledger that facilitates the process of recording transactions and tracking assets in a business network. An asset can be tangible (a house, car, cash, land) or intangible (intellectual property, patents, copyrights, branding). Virtually anything of value can be tracked and traded on a blockchain network, reducing risk and cutting costs for all involved.

https://ethereum.org/en/developers/docs/intro-to-ethereum/


    History
    -------------------
        - Oct 31, 2008: Origin of Bitcoin white paper. The paper described the creation of a system that would allow people each other directly without need for a central authority like a bank. 

        - The Bitcoin network was eventually brought online on Jan 2009, the original bitcoin network. The idea was based on idea of a blockchain.

        - The blockchain tech was then evolved and used to create different complex applications 

        - So, was the born of Ethereum, to enable creation of decentralised autonomous corporation

        - It introduced the idea of Smart Contract as an entity that can send and receive currency, beyond the humans. 

        - The Ethereum network became online on july 30th 2015.

    Types of blockchain networks
    ---------------------------------------
    - Public blockchain networks
        A public blockchain is one that anyone can join and participate in, such as Bitcoin. Drawbacks might include substantial computational power required, little or no privacy for transactions, and weak security. These are important considerations for enterprise use cases of blockchain.

    - Private blockchain networks
        A private blockchain network, similar to a public blockchain network, is a decentralized peer-to-peer network. However, one organization governs the network, controlling who is allowed to participate, execute a consensus protocol and maintain the shared ledger. Depending on the use case, this can significantly boost trust and confidence between participants. A private blockchain can be run behind a corporate firewall and even be hosted on premises.

    - Permissioned blockchain networks
        Businesses who set up a private blockchain will generally set up a permissioned blockchain network. It is important to note that public blockchain networks can also be permissioned. This places restrictions on who is allowed to participate in the network and in what transactions. Participants need to obtain an invitation or permission to join.

    - Consortium blockchains
        Multiple organizations can share the responsibilities of maintaining a blockchain. These pre-selected organizations determine who may submit transactions or access the data. A consortium blockchain is ideal for business when all participants need to be permissioned and have a shared responsibility for the blockchain.

    Bitcoin: 
        A Peer-to-Peer Electronic Cash System (https://bitcoin.org/bitcoin.pdf)

    Ethereum: 
        The Ultimate Smart Contract and Decentralized Application Platform (http://web.archive.org/web/20131228111141/http://vbuterin.com/ethereum.html)


    What is Ethereum
    --------------------------------
        - In Ethereum, we are dealing with a series of computers and networks. 

        - Ethereum networks are used to transfer money and store data.

        - There are many Ethereum networks. like Main, Test, Private...

        - Networks are formed by one or more nodes.

        - Each node is a machine running an ethereum client

        - Anyone can run a node

        - Each node can contain a full copy of the blockchain.

        - The blockchain is a database that stores a record of every movement of money between different parties or record of every transaction that has ever taken place.


    Interfacing with Ethereum Networks
    --------------------------------------------
        - For Developers: web3.js

        - For Consumers: Extension: Metamask
                         Mint Browser


    Metamask Account
    -----------------------
        Account Address: unique identifier

        Public Key: 

        Private Key: 

        - public and private key combinely form a password to send funds

        - Account Address, public and private key are stored as hexadecimal numbers

        - To see the decimal value, in web console, write
            0x<hex_number>

    Ethereum Networks
    ------------------------
        Main Network

        Ropsten Test Network

        Kovan Test Network

        Rinkeby Test Network

        Goerli Test Network

        localhost 8545


https://faucets.chain.link/rinkeby

https://faucet.rinkeby.io/

https://www.rinkeby.io/#stats



    
    What is a transaction
    --------------------------------
        - A transaction is described as one account attempting to send money to another account

        - During transaction, a object is created and submitted to Ethereum network to be processed

        - This object has different properties:
            1. nonce: How many times the sender has sent a transaction

            2. to: address of account this money is going to

            3. value: Amount of ether to send to the target address

            4. gasPrice: Amount of ether the sender is willing to pay per unit gas to get this transaction processed

            5. startGas/gasLimit: units of gas that this transaction can consume

            6. v: 
            7. r:
            8: s: 
                Cryptographic pieces of data that can be used to generate the senders account address. Generated from the sender's private key.
     
    - When users want to make a transaction, they must pay ether to have their transaction recognized on the blockchain. These usage costs are known as gas fees, and the gas fee depends on the amount of computing power required to execute the transaction and the network-wide demand for computing power at the time.

    Mining Process
    --------------------
    1. When we send a transaction object into a Ethereum network, it gets connected to a node in the network

    2. The node collects several of these transactions and combines them as one block to get processed in the blockchain i.e, inside the node.

    3. The node then runs some validation logic on the block to make this authentic, and that validation logic takes some amount of time to run and provide a response and is called mining or crypto-mining.

    https://andersbrownworth.com/blockchain/


    Block Time
    ----------------------
        - The amount of time it takes to find an appropriate nonce value to generate a required hash and complete the mining process is called block time.

        - Ethereum network has an ideal target block-time of 15 secs. After that the network will move to next block. But in practice, it is variable.

    

    Smart Contracts
    --------------------------
        - An account controlled by code.
        Contract Account
        -------------------
            Fields                      Description
          -----------                 ----------------
            balance                 Amount of ether this account owns

            storage                 Data storage for this contract

            code                    Raw machine code for this contract

        - The Metamask account owned by User/Individual, it is a external account. They are completel de-coupled from an individual networks, and reside in their own universe.

        - It can be used to connect to any of the network like Main/Rinkeby/Kovan...

        - Contract Accounts are specific to individual network. It can not be accessed in other network.

    

    Solidity
    ----------------
        - A programming language invented for developing smart contracts 

        - Written in .sol files

        - strongly typed 

        - similar to javascript

        - Has several huge gigantic 'gotchas'

        
                Contract Definition
                    (Solidity)
                        |
                        |
                        v
                Solidity Compiler
                        |
                        |
            ---------------------------------
            V                               V
        Byte code                   Application Binary
        ready for                   Interface (ABI)
        deployment


    https://remix.ethereum.org/

    
    A Simple Contract
    -----------------------
    pragma solidity ^0.4.17;

    contract Inbox {
        string public message;

        function Inbox(string initialMessage) public {
            message = initialMessage;
        }

        function setMessage(string newMessage) public {
            message = newMessage;
        }

        function getMessage() public view returns (string) {
            return message;
        }
    }


    pragma solidity ^0.4.17;
        Specifies the version of solidity that our code is written with
    
    contract Inbox {
        Defines a new contract(like classes) that will have some number of methods and variables

    string public message;
        Storage/Instance variable that will exist for the life of the contract.

        type scope <variable-name>;

    function Inbox(string initialMessage) public {
        Constructor function, automatically ccalled when the contract is first created


    Variable Declrations
    --------------------------
    Basic Types
    --------------------
    string              Sequence of characters                  "Hi There"

    bool                Boolean Value                           true / false

    int                 Integer, positive / negative,           1, -200, 0
                        no decimal

    uint                Unsigned Integer, Positive number       0, 10, 1000
                        no decimal

    fixed / ufixed      Fixed point number, Number with decimal  20.01, -10.23

    address             Has methods tied to it for sending money    0x141bhjv1g41v2412j4k14hj1b24h1j...


    Reference Types
    -----------------------
    fixed array             Array that contains a single type of element. Has an unchanging length.         int[3] -> [1, 2, 3]

    dynamic array           Array that contains a single type of element. Can change in size over time.     int[] -> [1, 2, 3]

    mapping                 Collection of key, value pairs. Think of objects in JS, Ruby hashes, Python     mapping(int => bool)
                            dictionaries, Java Maps. All keys must be of same type, and all values          mapping (string => string)
                            must be of the same type. 

    struct                  Collection of key value pairs that can have different types                     struct Car {
                                                                                                                string make;
                                                                                                                string model;
                                                                                                                uint value;
                                                                                                            }




    Function Declarations
    ----------------------------
        function <function-name>() <function-type> <return-type> { 

        } 

        function types
        -----------------
            public    - Anyone can call this function

            private   - Only this contract can call this function

            view      - This function returns data and does not modify the contract's data, can read data from blockchain
                OR
            constant  - This function returns data and does not modify the contract's data

            pure      - This function will not modify or even read the contract's data, can not read data from blockchain

            payable   - When someone call this function they might send ether along
            /////////////////////////////////////////////
            public - all can access

            external - Can NOT be accessed internally, only externally

            internal - only this contract and contracts deriving from it can access

            private - can be accessed only from this contract


    /* 
    // Getter method is provided by compiler if the storage scope is public
    function getMessage() public view returns (string) {
        return message;
    }
     */

    
    
    Behind the scene
    ------------------------------
        - Creating a contract is very similar to transfer of money between two parties.

        - whenever we want to send money from one person to another we are going to create a new transaction. 

        - This transaction will have the purpose to create a new contract. and we are going to send that from our account to a specific network and that's what make sure that specific network(rinkeby) attempts to create a new contract.

    
    External account to create a Contract Transaction 
    -----------------------------------------------------
        1. nonce: How many times the sender has sent a transaction

        2. to: <BLANK>, this shows we are going to create a new contract

        3. data: Compiled bytecode of the contract

        3. value: Amount of Wei to send to the target address

        4. gasPrice: Amount of Wei the sender is willing to pay per unit gas to get this transaction processed

        5. startGas/gasLimit: units of gas that this transaction can consume

        6. v: 
        7. r:
        8: s: 
            Cryptographic pieces of data that can be used to generate the senders account address. Generated from the sender's private key.


    - Any time we want to change any data in blockchain, we have to submit a transaction and wait for it to be mined, or to go through that validation algorithm which can take from 10 to 30 secs to get approved.


    - In above contract, setMessage involves a transaction as it is modifying the message data that is stored in Inbox contract, however, getMessage des not involve a transaction.

    - There are 2 ways in which we invoke functions that belong to our contracts and they result in very different behaviour.

    Calling a Function                  Sending a transaction to a function
    ----------------------              ----------------------------------------
    Can not modify contract's data      Can modify contract's data
    
    Can return data                     Returns transaction hash
    
    Runs instantly                      Takes time to execute

    Free to do                          Costs money!



    Wei vs Ether
    ---------------
        - They're different unit of measurement for Ethereum.

        like 1$ = 100cents

        1 Ether = 1,000,000,000,000,000,000 wei

        - other units: wei, Gwei, Finney, Ether

    
    Gas and Transaction
    ---------------------------------
        - In order to get someone else or some other service to run our contracts we have to pay them some money. 

        - This mone is reflected in terms of gas

        - When we send a transaction to Ethereum network, there is some amount of gas price attached to it.

        - Search google for gas price for yellow paper

        - GasPrice: Amount of wei the sender is willing to pay per unit gas to get this transaction processed

        - startGas/gasLimit: units of gas that this transaction can consume

        - Total cost to execute one transaction: 
                gasPrice * gasRequired
        
    

    Mnemonic Phrases
    -----------------------------
        - BIP39 mnemonic algorithm

        https://iancoleman.io/bip39/

        - Generate accounts from 12 word mnemonic

    

    Contract deployment
    -------------------------
        - To deploy remix editor takes care of that but for production, we need to use our own editor

        - To generate ABI and the byteCode, we use "Truffle"

        Truffle
        --------------
            Contract Creation

            Local Testing       ---------->     Rinkeby

            Deployment


    - https://trufflesuite.com/



    Boilerplate Design
    ---------------------------
    Issue                           Solution
    ---------                   -----------------------
    Need to be able to          Set up the Solidity compiler 
    write Solidity code         to build our contracts
    in a JS project

    Need some way to            Set up a custom Mocha test
    rapidly test contracts      runner that can somehow test
    without doing the manual    Solidity code
    testing like in remix

    Need some way to deploy     Set up a deploy script to 
    our contract to public      compile + deploy our contract
    networks

    - solc lib for solidity compiler
    - Ganache/TestRPC to create a local Eth Test Network
    - web3 lib as a portal to connect with contract


directory structure
    contracts
    scripts
    tests

 
>> npm i solc mocha ganache-cli web3@1.0.0-beta.26


    Web3.js
    ------------------  
        - require the constructor function from web3
        - create and instance of it
        - To create an instance we need to make some configuration and we have to set up a "provider"
        - provider can be thought of as a communication layer between web3 and some Ethereum Network
        - Every provider connecting to different networks has identical set of networks on it

        - They allow web3 to send request and receive response

    
    Testing with Mocha
    ------------------------------
        it          Run a test and make an assertion

        describe    Groups together "it" functions

        beforeEach  Execute some general setup code

        class Car {
            park() {
                return "stopped";
            }

            drive() {
                return "vroom";
            }
        }

        let car;
        beforeEach("Car setup", () => {
            car = new Car();
        });

        describe("Car", () => {
            it("car parking", () => {
                // const car = new Car();

                assert.equal(car.park(), "stopped");
                // assert.equal(car.park(), "stoppedd");
            });

            it("car drive", () => {
                // const car = new Car();

                assert.equal(car.drive(), "vroom");
            });
        });


Control Flow
------------------
    1. Mocha Starts

    2. Deploy a new contract (beforeEach)

    3. Manipulate the contract (it)

    4. Make an assertion about the contract (it) ----> go to 2


Infura API
-------------------------
    - Like ganache, but deploys to real rinkeby test network

    https://infura.io/


    PROJECT ID
    4279d3142bcf4543bd4e27b2fe31738c
    PROJECT SECRET
    338c0a6ceb184ae68e00f060f1e40375

    ENDPOINTS
    RINKEBY
    https://rinkeby.infura.io/v3/4279d3142bcf4543bd4e27b2fe31738c
    wss://rinkeby.infura.io/ws/v3/4279d3142bcf4543bd4e27b2fe31738c



>> npm i truffle-hdwallet-provider



- Whenever we create an instance and initiate a function call / transaction, a global object is assigned to it and that is "msg" object.

- It contains some properties / metadata about the contract.

msg.data        "Data" field from the call or transaction that invoked the current transaction

msg.gas         Amount of gas the current function invocation has available

msg.sender      Address of the account that started the current function invocation

msg.value       Amount of ether(in wei) that was sent along with the function invocation.




NOTE: Return dynamic string array
-------------------------------------------
// SPDX-License-Identifier: GPL-3.0
// pragma solidity ^0.4.17;
pragma solidity >=0.7.0 <0.9.0;

contract Lottery {
    address public manager;

    string[] public array;

    // function Lottery() public {
    constructor () {
        manager = msg.sender;
        array.push("hi");
        
    }

    function getData() public view returns (string[] memory) {
        return array;
    }
}


NOTE: Lottery Contract
-----------------------------------
pragma solidity ^0.4.17;

contract Lottery {
    address public manager;
    address[] public players;

    function Lottery() public {
        manager = msg.sender;
        
    }

    function enter() public payable {
        require(msg.value > 0.01 ether);
        
        players.push(msg.sender);
    }

    function random() private view returns(uint) {
        // sha3(block.difficulty, now, players);
        return uint(keccak256(block.difficulty, now, players));
    }

    function pickWinner() public restricted{
        // require(msg.sender == manager);

        uint index = random() % players.length;
        players[index].transfer(this.balance);

        players = new address[](0);
    }

    modifier restricted() {
        require(msg.sender == manager);
        _;
    }

    function getPlayers() public view returns(address[]) {
        return players;
    }
}








Frontend Ethereum App Architecture
================================================

                                            HTML/JS Assets                      Reading from the
                +<----------<---------<-----------------<------      Server     block chain can 
                |                                                               be done on the server
        Client  |
                |
                |   Web3
                +----------------------> Metamask   --------------->     Ethereum Network
                                    Public/Private     Transaction
                                    keys








Solving Real World Applications
============================================
    - Campaign scam or fraud



Campaign Contract
----------------------------

Request Struct:
    description string  Describes why the request is being created
    value       uint    Amount of money that the manager wants to send
    recipient   address address that the money will be sent to
    complete    bool    True if request has aready been processed
    ???         ???     voting mechanism


Storage vs Memory 
--------------------------------
    - Sometimes references where our contract stores data
    - Sometimes references how our solidity variables store values

 
    Storage: Holds data between function calls (like hard drive): like heap memory

    Memory: Temporary place to store data (like RAM): function arguments: like stack memory

    calldata: Like memory but can be used only in function inputs, and the data is not modifiable
            : while passing arguments to another function, for "memory", it creates a copy, but for calldata, it doesn't resulting in saving gas
    
    NOTE: Example on storage and memory
    pragma solidity ^0.4.17;

    contract Numbers {
        int[] public numbers;

        function Numbers() public {
            numbers.push(10);
            numbers.push(20);

            changeArray(numbers);
        }

        // function changeArray(int[] array) private {
        // function changeArray(int[] memory array) private {
        function changeArray(int[] storage array) private {
            array[0] = 1;
        }
    }

    - default is "memory", make a copy of the numbers and send it to changeArray function.

    - "storage" keyword specifies do not make a copy of the array and send the array as such.



Mapping vs Arrays
-----------------------------
    Key-value pairs

    Array: Linear search
    Mapping: Constant Search like Hashes of HashMap

    Mappings
    ----------------
        - Keys are not stored
        - Search happens through Hash Table
        - Values are not iterable
        - All values exist





NOTE: Campaign Contract
-------------------------------
pragma solidity ^0.4.17;

contract CampaignFactory {
    address[] public deployedCampaigns;

    function createCampaign(uint minimum) public {
        address newCampaign = new Campaign(minimum, msg.sender);

        deployedCampaigns.push(newCampaign);
    }
 
    function getDeployedCampaigns() public view returns(address[]) {
        return deployedCampaigns;
    }
}

	

contract Campaign {
    struct Request { // struct is a type just like string / uint
        string description;
        uint value;
        address recipient;
        bool complete;
        uint approvalCount;
        mapping(address => bool) approvals;
    }

    Request[] public requests;
    address public manager;
    uint public minimumContribution;
    // address[] public approvers;
    mapping(address => bool) public approvers;
    uint public approversCount;

    modifier restricted() {
        require(msg.sender == manager);
        _;
    }
    
    function Campaign(uint minimum, address creator) public {
        manager = creator;
        minimumContribution = minimum;
    }

    function contribute() public payable {
        require(msg.value > minimumContribution);

        // approvers.push(msg.sender);
        approvers[msg.sender] = true;
        approversCount++;
    }

    function createRequest(string description, uint value, address recipient) public restricted {

        Request memory newRequest = Request({
            description: description,
            value: value,
            recipient: recipient,
            complete: false,
            approvalCount: 0
        });

        /* 
            Alterntive syntax: pass values in order
            Request req = Request(description, value, recipient, false);
        */

        requests.push(newRequest);
    }

    function approveRequest(uint index) public {
        Request storage request = requests[index];

        require(approvers[msg.sender]);
        require(!request.approvals[msg.sender]);
        
        request.approvals[msg.sender] = true;
        request.approvalCount++; 
    }
    
    function finaliseRequest(uint index) public restricted {
        Request storage request = requests[index];

        require(request.approvalCount > (approversCount / 2));
        require(!request.complete);

        request.recipient.transfer(request.value);

        request.complete = true;
    }

}














Truffle Suite
=================================
    https://trufflesuite.com/tutorial/index.html

    - npm i -g truffle

    >> truffle unbox pet-shop

    Directory structure
    The default Truffle directory structure contains the following:

    - contracts/: Contains the Solidity source files for our smart contracts. There is an important contract in here called Migrations.sol, which we'll talk about later.
    
    - migrations/: Truffle uses a migration system to handle smart contract deployments. A migration is an additional special smart contract that keeps track of changes.
    
    - test/: Contains both JavaScript and Solidity tests for our smart contracts
    
    - truffle-config.js: Truffle configuration file
    
    The pet-shop Truffle Box has extra files and folders in it, but we won't worry about those just yet








DeFI
==================
    Pillars of DeFI
        - StableCoin
        - Lending and Borrowing
        - Decentralized Exchanges
        - Insurance
        - Margin Trading

</pre>
</div>


<div id="csamm">
    <pre>

AMM (Automated Market Maker)
==============================================
    - It is DEX where the price of a token is determined by mathematical equation defined in the contract.

    - This is wrt centralized exchange, where the price of an asset/token is determined by traders

    - You can 
        1. Add Liquidity
        2. Swap
        3. Remove Liquidity
        in an AMM
    
    - When an user adds Liquidity, they are adding tokens into the AMM and is called a Liquidity Provider

    - When a users provides liquidity the AMM mints shares back to the user.  
    - The share represents partial ownership of the total liquidity

    - A swap is when a user trades a token 
    - User trading 10 Token B to get 10 Token A

    - Remove Liquidity
    - An user is withdrawing his tokens in exchange for his shares

    - the amount of tokens being traded and the amount of tokens user gets back when the user calls remove liquidity depends on the AMM

Questins to ask
    - Why this AMM is called CSAMM
    - How many tokens does a user get back in a trade
    - How many shares are minted when a liquidity provider adds liquidity
    - How many tokens does a liquidity provider get back when the liquidity provider removes liquidity.

=> CSAMM : Constant Sum Automated Market Maker
---------------------------------------------------------
    price of tokens are determined by equation:
        X + Y = K

        X = amount of token A in the AMM
        Y = amount of token B in the AMM

        upon added we get a constant called K

    - when a user trades in CSAMM, the cconstant K must remain same regarless of X and Y changes.
    
    example: 
        User sells token A and buy Token B

        dx = amount of token A coming in 
        dy = amount of token B going out

        B
        |
        |\
        | \    X + Y = K
        |  \
        |   \
        |    \
        |     \
        |      \  
       -|-------\------------------------- A

- Swap: How many tokens to return in a trade
    - Trade from Token A to Token B (sell A to get B)
    - seller puts A token into AMM to get B in return

    Before the trade            After the trade
    X + Y = K                   X + dx + Y - dy = K

                            => X + dx + Y - dy = X + Y
                            => dx + dy = 0
                            => dx = dy

                    Amount of token in = Amount of token out

    example:
        Token in = user Selling = Token A = 100
        How many B will the user get in return

        dx = 100;
        dy = dx = 100;
        Token out = User Receiving = Token B = 100

- Add Liquidity - How many shares to mint
    - Increase in liquidity is proportional to Increase in total shares

    a = Amount in
    L = Total liquidity before new liquidity is added
    s = Amount of shares to mint
    T = Total shares before mint

        L + a     T + s
    =>  ------ = -------
          L         T

    =>  s = a*T / L

    a = dx + dy
    L = X + Y

            (dx + dy) * T
     => s = ----------------
                X + Y 

- Remove Liquidity - How many tokens to withdraw
    - withdraw tokens proportional to shares

    a = amount out
    L = Total Liquidity
    s = amount of shares to burn
    T = Total shares

        a       s
    => ---  =  ---
        L       T

    => a = (L * s) / T

                (X + Y) * s
    => dx + dy = --------------
                    L


    => dx = Xs / T
    => dy = Ys / T
</pre>
</div>


<div id="cpamm">
    <pre>
=> CPAMM : Constant Product Automated Market Maker
---------------------------------------------------------
    - Price of tokens are determined by the equation
        XY = K

        X = amount of Token A in the AMM
        Y = Amount of Token B in the AMM

    example:
        Sell token A and buy Token B
        dx = Amount of Token A in
        dy = Amount of Token B out

        Before the trade: XY = K
        After trade = (X + dx)(Y-dy) = K

    => (X + dx)(Y - dy) = XY


- Swap -  How many token to return in a trade
            Y * dx
    dy = ------------- 
            X + dx

            X * dy
    dx = -------------
            Y + dy

    - swap from token A to Token B
    dx = amount of token A in
    dy = amount of token B out

    Before swap 
        XY = K
    
    After Swap
        (X + dx)(Y-dy) = K
    
    => (X + dx)(Y - dy) = XY
    divide above equation by (X + dx)
                   K
    => dy = Y - --------
                 X + dx

    replace K with XY
                   XY
    => dy = Y - --------
                 X + dx

             YX + Ydx - XY
    => dy = ----------------
                 X + dx
    
                  Ydx 
    => dy = ----------------
                 X + dx


- Add Liquidity - How many shares to mint
          dx        dy
    s = ------ T = ----- T
          X         Y

    Before adding
        XY = K 
    After adding
        (X + dx)(Y + dy) = K'

    then, 
        K <= K'

    constraint is
        - No price change before and after adding liquidity

     X     X + dx
    --- = ---------
     Y     Y + dy

    What is dy given dx?         What is dx given dy?
        - Find dy                   - find dx
     X     X + dx
    --- = ---------
     Y     Y + dy

    => X(Y + dy) = Y(X + dx)     
    => XY + Xdy = XY + Ydx
    => Xdy = Ydx
    => X/Y = dx/dy

            Ydx                        Xdy
    => dy = ---               => dx = -----
             X                          Y

   
    => dx/dy = X/Y


- How many shares to mint
    - Increase in liquidity is proportional to Increase in shares

    L0 = total liquidity before adding
    L1 = total liquidity After adding
    T = total shares before
    s = shares to mint

        L1     T + s
    => ---- = --------
        L0       T

        L1 * T   
    =>  ------ = T + s
          L0       

            L1 * T
    => s =  ------- - T
              L0

            L1 - L0
    => s =  -------- * T
              L0


    How to measure total liquidity from X and Y
        f(X,Y) = total liquidity

        f(X,Y) = sqrt(X.Y)

    motivation:
        - XY = K
        after adding liquidity increases K
        (X + dx)(Y + dy) = K'

        f(X,Y) shoulb be linear
        f(X,Y) <= c * max(X, Y)

    L0 = sqrt(X.Y)

         2|-------------------
    L1 = \| (X + dx) (Y + dy)

        L1 - L0     dx      dy
    =>  -------- =  ---  = ----
           L0        X       Y

            dx       dy
    => s = ---- T = ----- T
            X         Y


- Remove liquidity ; how many tokens to withdraw
               s
    => dx = X ---
               T
               s
    => dy = Y ---
               T

    - withdraw tokens proportional to shares

    a = amount to withdraw = f(dx, dy) = sqrt(dx . dy)
    L = total liquidity = f(X,Y) = sqrt(X.Y)
    s = Amount of shares to burn
    T = total shares

    => a/L = s/T
    => a = L * (s/T)
        |----------      |------  s
    => \| dx . dy     = \| X.Y   ---  
                                  T

    => Find dx
        |----------         |------  s
    =>  |  dx . Ydx      = \| X.Y   ---  
        |       ---                  T
       \|        X


         |---------      |-------  s
    => dx|  Y / X     = \| X.Y    ---
        \|                         T

                s
    => dx  = X ---
                T


Constant Product Spot Price
-----------------------------------------------
    X = amount of token A in pool
    Y = amount of token B in pool

    P = spot price of token B in terms of token A
        exchange rate from A to B
      = Y / X
    
    From Graph: swap equation
    ------------
        (X + dx)(Y - dy) = K

        dy          Y
       -----  =  ---------
        dx        X + dx 
    as dx ----> 0
        dy/dx -------> Y/X (slope)

    => P = Y/X


    From Calculus
    -----------------
    XY = K
    => Y = f(X) = K/X

    derivative of F, F'
    => f'(X) = -K / (X^2)
    => f'(X) = -XY / (X^2)
    => f'(X) = -Y / X 
        -(minus) is the slope, as Y is token out

</pre>
</div>



<div id="vault">
    <pre>
Vault
============================
    What is Vault
        - Vault is a contract where user first deposits his token 
        - This token can be either USDC, DAI, ETH etc...
        - Later the user will be able to withdraw the token 
            + profits (if the vault makes profits)
            - loss (if the vault loses money)

        - while withdrawing, the vault contract burns his shares

           deposits $             Vault owner
    User ------------->   Vault  ---------------->  Other DeFI protocols
         <-------------          invest in other
            mint shares          DeFI protocols
                                 and make profit

    - Deposit: how much shares to mint
        - shares to mint is proportional to increase in balance of vault
        a = amount to deposit
        B = Balance of value before deposit
        s = shares to mint
        T = Total shares before mint


        a + B       s + T
        ------  =  -------
          B           T

    => (a + B)T = (s + T)B
    => aT + BT = sB + TB
    => aT = sB

    => s = aT / B

    - Withdraw: how much amount to withdraw
        a = amount to withdraw
        B = Balance of value before withdraw
        s = shares to burn
        T = Total shares before burn

        B - a       T - s
        ------  =  -------
          B           T

    => (B - a)T = (T - s)B
    => BT - aT = TB - sB

    => a = sB / T

    </pre>
</div>

<pre>

Tokens in Blockchain
-----------------------------------
https://www.youtube.com/watch?v=422HORNUfkU
https://www.youtube.com/watch?v=4dkl5O9LOKg

    - Platform Token
        - created to support a DAPP on blockchain, uniswap, 
    
    - Security Tokens
        - minted to represent ownership of another asset

    - Transactional Tokens
        - faster way to transfer money

    - Utility Tokens
        - Value tied to their ownership
        - Brave Token (BAT: Basic Attention Token)
    
    - Governance Token
        - allow users to vote on certain things

</pre>
    
<div id="syntetix">
    <pre>
Syntetix Staking Reward
=========================================
    - Earn rewards for Staking
    - Owner can set the rewards and duration
        - amount to pay
        - for the duration they will be paying
    
    - then owner sends the reward token into the staking reward contract
    - User now can stake their token and start earning rewards
    
    let's say user stakes 200 tokens into the staking reward contract
    before the user, many other users also have staked their tokens
    Lets say there are total 2000 tokens staked inside the contract
    1 week later, user withdraws all the 200 tokens that he staked

    rewards = 

        (200/2000) * (1000/week * 1 week)
         = (1/10) * (1000)
         = 100 rewards

    Math
    --------------
    r(u,k,n) = rewards(r) earned by user u from k to n seconds

    Si = amount staked by user u at time = i
    Ti = total staked by all users at time i (Assume Ti > 0)
    R = reward rate per second (total rewards / duration)

        n - 1
        _____
    r = \       (Si / Ti) * R
        /____
         i = k


    Furthermore, when
        Si = constant S for time k ot n-1

                 n - 1
                 ______
    r(u,k,n) = S \      R / Ti
                 /_____
                 i = k
             +‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì                       ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì+
             |   n - 1               k - 1           |
             |   ______             _______          |
    => S  *  |   \      R / Ti  -   \       R / Ti   |
             |   /_____             /______          |
             |   i = 0              i = 0            |
             |________                       ________|


    => S * (reward per token - user reward per token paid)

    Rewrite the equation
        Define reward per token at time j
        r0 = 0

            j - 1
            ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì
       rj = \      R / Ti     <---- 0 if Ti = 0 
            /______
            i = 0

        When Ti = T, at time i for jo <= i < j
          +‚Äì‚Äì‚Äì‚Äì                   ‚Äì‚Äì‚Äì‚Äì‚Äì+
          |                R           |
          |  rj = r(jo) + --- (j - jo) |
          |                T           |
          +‚Äì‚Äì‚Äì‚Äì                   ‚Äì‚Äì‚Äì‚Äì‚Äì+  

    proof:

             j - 1
            ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì
       rj = \      R / Ti     <---- 0 if Ti = 0 
            /______
             i = 0


        +‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì                       ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì+
        |   j0 - 1              j - 1           |
        |   ______             _______          |
    =>  |   \      R / Ti  -   \       R / Ti   |
        |   /_____             /______          |
        |   i = 0              i = j0           |
        |________                       ________|
         Ti is constant T, for jo <= i < j

                        j - 1
                    R   ‚Äì‚Äì‚Äì‚Äì
        = r(j0) +  ---  \    1
                    T   /___
                        i = j0

                              n              
                            ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì
                        =>  \       1   =  n - k + 1
                            /_____
                             i = k

        +‚Äì‚Äì‚Äì‚Äì                   ‚Äì‚Äì‚Äì‚Äì‚Äì+
        |                R           |
    =>  |  rj = r(jo) + --- (j - jo) |
        |                T           |
        +‚Äì‚Äì‚Äì‚Äì                   ‚Äì‚Äì‚Äì‚Äì‚Äì+ 

 

‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì
\
/_____



    Examples
    --------------
        n - 1
        _____
    r = \       (Si / Ti) * R
        /____
         i = k
    Si = amount staked by user u at time = i
    Ti = total staked by all users at time i (Assume Ti > 0)
    R = reward rate per second (total rewards / duration)

    1. Alice stakes 100 token for 3 seconds
    How many rewards earned by Alice?

    at 3-4 sec   at 4-5 sec     at 5-6 sec
    100          100            100
    ---- R   +   ---- R    +    ---- R
    100          100            100

    => 3R (amount of rewards Alice will receive for 3 seconds)


    2. Alice stakes 100 for 4 seconds
       Bob stakes 200 for 5 seconds
        How many rewards are earned by Alice?

        3 Alice stakes 100
        5 Bob stakes 200
        7 Alice withdraws 100
        10 Bob w ithdraws 200

  at 3-4 sec   at 4-5 sec  at 5-6 sec  at 6-7 sec
    100         100        100          100
    --- R    +  --- R    + --- R     +  --- R 
    100         100        300          100

    => R + R + (1/3)R + (1/3)R
    => 2R + (2/3)R
    
    => (8/3) R



             +‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì                       ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì+
             |   n - 1               k - 1           |
             |   ______             _______          |
    => S  *  |   \      R / Ti  -   \       R / Ti   |
             |   /_____             /______          |
             |   i = 0              i = 0            |
             |________                       ________|

        +‚Äì‚Äì‚Äì‚Äì                   ‚Äì‚Äì‚Äì‚Äì‚Äì+
        |                R           |
    =>  |  rj = r(jo) + --- (j - jo) |
        |                T           |
        +‚Äì‚Äì‚Äì‚Äì                   ‚Äì‚Äì‚Äì‚Äì‚Äì+ 
 
    3. secs 3: Alice stakes 100
            5: Bob stakes 200
            6: Carol stakes 100
            9: Alice withdraws 100
           10: Carol stakes 100
           11: Bob withdraws 200
           13: Carol withdraws 200
        
        User rewards per token
        --------------------------
        Alice: r3, r9
        Bob: r5, r11
        Carol: r6, r10, r13

    at 0 sec: r0 = 0                               
    at 3 sec: r(3) = r0 + 0 * (3 - 0) (as T = 0)   
    at 5 sec: r(5) = r3 + (R/100) * (5-3) 
                   = 0  + (2R / 100)
                   = 2R / 100
    at 6 sec: r(6) = r5 + (R/300) * (6-5)
                   = 2R     1R
                     --- + ----
                     100    300

    at 9 sec: r(9) = r6 + (R/400) * (9-6)
                     2R     1R     3R
                  =  --- + ---- + ----
                     100    300    400

    Alice:
             +‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì                       ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì+
             |   n - 1               k - 1           |
             |   ______             _______          |
    => S  *  |   \      R / Ti  -   \       R / Ti   |
             |   /_____             /______          |
             |   i = 0              i = 0            |
             |________                       ________|

        staked at 3 sec and withdraw at 9 sec

        Alice: 100 (staked) * (r9 - r3)
                    +‚Äì‚Äì‚Äì‚Äì               ‚Äì‚Äì‚Äì‚Äì‚Äì+
            => 100 *|  2R     1R     3R      |
                    |  --- + ---- + ---- - 0 |
                    |  100    300    400     |
                    +____               _____|    

            => 

    at 10 sec: r(10) = r9 + (R/300) * (10-9)
                        2R     1R     3R     R
                     =  --- + ---- + ---- + ----
                        100    300    400    300

        Carol: 100 (staked) * (r10 - r6)
                     +‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì                               ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì+
            => 100 * | 2R     1R     3R     R           2R     1R  |
                     | --- + ---- + ---- + ----    -   ---- - ---- |
                     | 100    300    400    300         100    300 |
                     |_______                               _______|

                      +‚Äì‚Äì‚Äì     ‚Äì‚Äì‚Äì‚Äì‚Äì+
            =>  100 * |  3R     1R  |
                      | ---- +  --- |
                      |  400    300 |
                      |___      ____|
    
    at 11 sec: r(11) = r10 + (R/400) * (11 - 10)
                        2R     1R     3R     R      R
                     =  --- + ---- + ---- + ---- + ---
                        100    300    400    300   400

        Bob: 200 (staked) * (r11 - r5)
                  +‚Äì‚Äì‚Äì‚Äì                             ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì+
            200 * |  2R     1R     3R     R      R    2R   |
                  |  --- + ---- + ---- + ---- + --- - ---  |
                  |  100    300    400    300   400   100  |
                  |____                             _______|

            =     +‚Äì‚Äì‚Äì‚Äì                ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì+
            200 * |  1R     3R     R      R   |
                  | ---- + ---- + ---- + ---  |
                  |  300    400    300   400  |
                  |____                _______|

    at 13 sec: r(13) = r11 + (R/200) * (13-11)
                        2R     1R     3R     R      R    2R
                     =  --- + ---- + ---- + ---- + --- + --- 
                        100    300    400    300   400   200

        Carol: 200 (staked) * (r13 - r10)

               +‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì
               |  2R     1R     3R     1R    1R    2R
         200 * |  --- + ---- + ---- + ---- + --- + --- 
               |  100    300    400    300   400   200   
               |______                      ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì+
                        2R     1R     3R     R    |
                     -  --- - ---- - ---- - ----  |
                        100    300    400    300  |
                                            ______|

                  +‚Äì‚Äì‚Äì       ‚Äì‚Äì‚Äì‚Äì+
          = 200 * | 1R     2R    |
                  |---- + -----  |
                  | 400    200   |
                  |____      ____|


    Algorithm
    ----------------------
    On Stake or Withdraw
        - Calculate current reward per token
            r += (R/totalSupply) * (curTime - lastUpdateTime)

        - Calculate amount of rewards earned by user
            rewards[user] += balanceOf[user] * (r - userRewardPerTokenPaid[user])

        - Update the user reward per token paid
            userRewardPerTokenPaid[user] = r

        - update last token update time / the last time the reward was calculated
            lastUpdateTime = curTime

        - update the amount of tokens staked by user
            balanceOf[user] +/- = amount  (+ on stakinf, - on withdrawing)

        - update totalSupply
            totalSupply +/- = amount

    </pre>
</div>   

<div id="compound">
    <pre>

Compound Finance
==================================
Borrowers and Lenders, just like a bank
    Borrowers: take money from the protocol
    Lenders: provide assets to be lent by the borrowers


            +‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì> cToken DAI
            |
            |
            +‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì> cToken BAT
            |
Comptroller |
            |.... etc
            |
            |


    - we will have to interactwith one of cToken, when we want to lend or borrow token

    - when user wants to borrow a token, Comptroller, will check that whether user has enough collateral across Ctokens.

    - in most cases, cToken will ask the Comptroller to perform the operations, except a few cases where you will have to interact with it directly

    - Comproller contains the primar logic of the compound finance

    Borrowing
    ---------------
        1. provide a collateral to compound
                        dai tokens
                  +‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì>
        Borrower  |                     cDAI (contract)
                  <‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì
                        cDAI tokens
            - if you want to use DAI as a collateral then we have to send some DAI to cToken DAI and we call it cToken cDAI

            - now in exchange cDAI contract will give us another token is called cDAI, 

            - cDAI represents the DAI token we sent to compound, and at any time we can redeem the cDAI to get the real DAI token that we sent
            
        2. enterMarket()
                        enterMarket()
                  +‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì>
        Borrower  |                     comptroller
                  
                      
            - you say that you are willing to use a certain set of token as collateral for borrowing other tokens

        3. Borrow token
                        borrow()
                  +‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì>
        Borrower  |                     cBAT (contract)
                  <‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì
                        bat tokens

            - call the borrow() on cBAT smart contract
        
        4. repay Token
                        bat tokens
                  +‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì>
        Borrower  |                     cBat (contract)

            - there is no duration for the loan
            - you can pay back the loan whenever you want
            - the longer the loan the higher the interest
        
        5. Repay Token - redeem()

                        cdai tokens
                  +‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì>
        Borrower  |                     cDAI (contract)
                  <‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì
                        DAI tokens

            - getback the collateral DAI tokens that you've put in the compound
            - you will redeem() cDAI tokens, it will be sent to cDAI contract and it will return the DAI token that you've kept

            -  you will get something extra as you'll have earned some interest during this time

            - you can keep this amount without the redeem and can keep earning interest 
            


    Liquidation
    ------------------------------
        What is it?
            - on compound when you borrow more than what you supplied, then you are subjected to Liquidation

            - it means that someone else can repay a portion of the token that you borrowed and in return that person receives the token that you suppplied at a discount

            - to create a situation where the burrowed amount is greater than the amount that was supplied  


</pre>
</div>

<div id="uniswap">
    <pre>
UNISWAP
====================
V1 Docs: https://github.com/Uniswap/v1-docs
https://github.com/Uniswap/v1-contracts

V2 Docs: https://docs.uniswap.org/protocol/V2/reference/smart-contracts/factory

V3 docs: change the version in V2

Good Resource: https://mirror.xyz/roherrera.eth/6hT_130LSkBjFALYUzXVi95TJX3mWdMr049gPfcj3i0
DEFI-UNI-1: https://jeiwan.net/posts/programming-defi-uniswap-1/

pre-requisites: 
  Liquidity Providers, Traders, Liquidity Pools, Swapping, ETH, ERC20

Model of Uniswap
  Traders <‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì> Liquidity Pool <‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì> Liquidity Provider

  Earn from UNI by 
    - performing buy and sell ERC20 tokens 
    - by becoming a Liquidity Provider for Uniswap

  - Liquidity Provider(LP) need to send equal amouunt of Ether and ERC20 tokens to a specific pool and in exchange they will be given liquidity tokens to represent the asset he has provided.

  - A LP at any point can redeem those Liquidity tokens agaisnt the assets in the pool. 
  
  - Traders are able to buy or sell ERC20 Token of that specific pool

  - If a trader wants to buy some ERC20 Token he will send some ETH to the Liquidity pool and he will receive the ERC20 token in exchange. 

  - He will also provide a transaction fee which will be give to LP when they withdraw their asset

  - At no point a Trader trades directly with Liquidity Providers, they trade with the Liquidity Pool only

  - The price of the ERC20 and ETH in the liquidity pool is set automatically to keep them balanced

  X = ERC20, Y = ETH
  - If someone buys ERC20 token, 
  X:Y = 1:1
  X decreases compared to Y
  in this case smart contract will increase the price of ERC20 token incentivizing the traders which will re-balance the liquidity pool.

  Smart Contracts
  ------------------------
                          Factory

      Exchange      Exchange      Exchange      Exchange
      ETH/BAT       ETH/ZRX       ETH/DAI       ETH/BTC   ...etc

      - There is one extended smart contract per pair of asset
      - that's where the liquidity pools are and where trading actually happens.

      - There is only one Factory smart contract
      - The responsibilities of Factory is to create the exchanges smart contract and act as a registry for these excahnges.

      - V1 is written in Vyper
        https://github.com/Uniswap/v1-docs

      - V2 is written in solidity

      // Solidity Interface Uniswap V1 Factory
      contract UniswapFactoryInterface {
          // Public Variables
          address public exchangeTemplate;
          uint256 public tokenCount;

          // Create Exchange
          function createExchange(address token) external returns (address exchange);

          // Get Exchange and Token Info
          function getExchange(address token)
              external
              view
              returns (address exchange);

          function getToken(address exchange) external view returns (address token);

          function getTokenWithId(uint256 tokenId)
              external
              view
              returns (address token);

          // Never use
          function initializeFactory(address template) external;
      }

      
      
  Uniswap V2
  -------------------
      interface IUniswapV2Factory {
        event PairCreated(address indexed token0, address indexed token1, address pair, uint);

        function feeTo() external view returns (address);
        function feeToSetter() external view returns (address);

        function getPair(address tokenA, address tokenB) external view returns (address pair);
        function allPairs(uint) external view returns (address pair);
        function allPairsLength() external view returns (uint);

        function createPair(address tokenA, address tokenB) external returns (address pair);

        function setFeeTo(address) external;
        function setFeeToSetter(address) external;
      }

    Goerli Testnet: https://goerli.etherscan.io/address/0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f#code

    - Factory: Create different market in uniswap and act as a registry for Different market

    - Pair: Each market is represented by smart contract called Pair Smart contract

    - In each Pair you have 2 tokens: DAI/WETH, USDC/WETH, 
    
    - Router: It is a utility which helps you to use Uniswap in a simpler way

    - ERC20: Tokens that are manipulated by Uniswap

                      Factory

        PAIR          PAIR         PAIR          PAIR
      ETH/BAT       ETH/ZRX       ETH/DAI       ETH/BTC   ...etc

    - 1WETH token = 1ETH

    - In uniswapV1 you can create markets with Ether but in V2 you can create PAIR with WETH

    - Anybody can create a PAIR and this is a permissionless system, you need to call Factory Smart Contract to create a PAIR

    Interacting with PAIR
    --------------------------------
      - 2 person can interact with a PAIR
        1. Liquidity Provider
        2. Traders

                        DAI + WETH
      Liquidity  ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì>     PAIR
      Provider   <‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì   DAI/WETH
                      LP Token

      
      - If a PAIR is of DAI/WETH then a LP can provide both of same value and receive LP tokens as a redeemable token

      - Plus you will also get the trading fee that will earn by the PAIR smart contract in the meantime

                  WETH + trading fees
      Trader   ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì>     PAIR
               <‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì   DAI/WETH
                        DAI

                        
    - It can get tricky to interact directly with PAIR smart contract so uniswap Router that can be used as a conduit or convenience in order to interact with the PAIR

    - If you are building your own system around uniswap, it's recommended to use Router smart contract instead of directly interfacing with the PAIR contracts

                                          PAIR
    Trader ‚Äì‚Äì‚Äì>‚Äì‚Äì‚Äì‚Äì‚Äì+        +‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì> DAI/WETH  
                    | Router |
    Liquidity ‚Äì‚Äì>‚Äì‚Äì‚Äì+        +‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì> PAIR
    Provider                            USDC?WETH


    - Advantages for using Router is you can have complex trading using the Router

    - Let's say there are 2 PAIRS available, DAI/WETH and DAI/USDC but iur requirement is DAI/USDC which is not available

    - Here we can specify a route to the router smart contract, we will use the DAI/WETH Pair and then the USDC/WETH Pair, that way we can synthetically create the DAI/USDC market

    - You can also use ETH to trade on uniswap and Router will automacically convert back and forth between ETH and WETH

    - otherwise if you trade directly with the pair, you have to take care of the yourself of wrapping your ETH into a WETH token first. 

    
  Pricing in UniswapV2
  ===============================
      - It uses CPAMM(Constant Product Automated market Maker)

      => X * Y = K

      Swapping X with Y means you will provide X to get Y

      dx = amount of X token provided
      dy = amount of Y token to be received

      as you provide dx, X token will increase in liquidity
      as you receive dy, Y token will decrease in liquidity

    After Swap  
      => (X + dx)(Y - dy) = K

                   K
      => dy = Y - --------
                  X + dx

      replace K with XY
                    XY
      => dy = Y - --------
                  X + dx

              YX + Ydx - XY
      => dy = ----------------
                  X + dx
      
                    Ydx 
      => dy = ----------------
                  X + dx

    Uniswap hasa trading fee of 0.3%

              Y * 0.997 * dx 
      => dy = ----------------
                  X + dx

    
    How much can I add to Liquidity Pool
    -------------------------------------------
      -  https://www.youtube.com/watch?v=YfLmaCaVYn8&list=PLO5VPQH6OWdX-Rh7RonjZhOd9pb9zOnHW&index=4

    Optimal One-sided supply
    ------------------------------
      - I have 1000DAI and 0 ETH and I want to become a LP for uniswap

      - Sell half of the DAI, and get ETH in return

      - now send both DAI and ETH into Uniswap to become LP

      - IT took all DAI but not all ETH to maintain the ratio, it returned the extra ETH 

      - not I have some tokens which are un-utilised, here ETH
      - Ideally I would like to utilise all of my tokens for Liquidity

      - Then we can find a optimal amount to swap so that we can minimze the amount of tokens that are un-utilized

      - We want optimal amount of DAI to swap so that after adding Liquidity the amount of ETH left at our hand is as low as possible

      Optimal amount to swap:
      -----------------------------
        A = amount of token A in Uniswap = DAI
        B = amount of token B in Uniswap = ETH
        f = trading fee
        a = amount of token A that I have
        b = amount of token B that I need
        s = amount of token to swap from A to B

        find b and s

        => A * B = K

        => (A + (1-f)s)(B - b) = K
        (1-f)s : % of s adding to A

                B * ( 1-f)s
        => b = --------------
                A + (1 - f)s

        
        After the swap, the reserve ratio for A to B is
          A + s      a - s
        --------- = --------
          B - b        b


        => (1-f)s^2 + A(2-f)s - aA = 0

        => Solving for qudratic equation
                           +‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì
               - (2-f)A + \| ((2-f)A)^2 + 4(1-f)Aa
        => s = ----------------------------------------------
                            2(1-f) 

        => f = 0.3% = 3/1000

                          +‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì
               - 1997A + \| 3988009 * A + 3988009 * Aa
        => s = ----------------------------------------------
                          1994

      s is the amount of token A we need to swap to token B so that we can miximize liquidity by using the above formula


    </pre>
    </div>
    
</body>
</html>